const Projects = artifacts.require("Projects");
const time = require('./utils.js');

/*
These tests are run with a local blockchain generated by Ganache. It generates
the blockchain and creates 10 Accounts with test ether. We can access these
accounts by their indices i.e accounts[2]. This allows us to run tests modelling
interactions with multiple project creators and donators.
*/

 contract('Projects', async accounts => {

   it('should deploy the contract properly', async() => {
     let contractInstance = await Projects.deployed();

     // if the contract has an address it has been deployed
     assert(contractInstance.address !== "", "Contract is not deployed");
   });

   it('Should create a Project correctly', async () => {
     let contractInstance = await Projects.deployed();

     // create sample inputs in the correct format
     // incorrect format error handling is done on the frontend
     var testProjectInfoHash = "qwgfjfdjkgfkjghdfkgh";
     var testFundingGoal = 10.000;
     var today = new Date();
     // the end date attribute is a timestamp
     // this creates the timestamp of an arbitrary date many days after today
     var testProjectEndDate = Math.floor(today / 1000) + 50000000;

     // The result of calling a function on the blockchain is a reciept
     let result = await contractInstance.createProject(testProjectInfoHash,
                                                       testFundingGoal,
                                                       testProjectEndDate);

     // if the status of this recipt is true, the function executed successfully
     assert.equal(result.receipt.status, true, "Project creation failed");
   });

   it('Should create 3 more Projects correctly', async () => {
     let contractInstance = await Projects.deployed();
     var testProjectInfoHash = "qwgfjfdjkgfkjghdfkgh";
     var testFundingGoal = 10.000;
     var today = new Date();
     var testProjectEndDate = Math.floor(today / 1000) + 50000000;
     let result1 = await contractInstance.createProject(testProjectInfoHash,
                                                        testFundingGoal,
                                                        testProjectEndDate);
     let result2 = await contractInstance.createProject(testProjectInfoHash,
                                                        testFundingGoal,
                                                        testProjectEndDate);
     let result3 = await contractInstance.createProject(testProjectInfoHash,
                                                        testFundingGoal,
                                                        testProjectEndDate);
     assert.equal(result1.receipt.status, true, "Project creation failed");
     assert.equal(result2.receipt.status, true, "Project creation failed");
     assert.equal(result3.receipt.status, true, "Project creation failed");
   });

   it('Should return 4 projects in the correct format', async () => {
     let contractInstance = await Projects.deployed();

     // the return projects function retruns an array of maps
     // the keys of the maps are the atrribute names which point to their value
     let projectsMap = await contractInstance.returnProjects.call();
     // should contain 4 projects
     assert.equal(projectsMap.length, 4, "Projects Map not the correct length");
     // and all the relevant keys
     assert.equal(("creatorAccount" in projectsMap[1]),
                   true,
                   "Project missing creator account key");
     assert.equal(("projectInfoHash" in projectsMap[1]),
                   true,
                   "Project missing projectInfoHash key");
     assert.equal(("fundingGoal" in projectsMap[1]),
                   true,
                   "Project missing funding goal key");
     assert.equal(("amountRaised" in projectsMap[1]),
                   true,
                   "Project missing amount raised key");
     assert.equal(("projectEndTime" in projectsMap[1]),
                   true,
                   "Project missing project end time key");
   });

   it('Should donate 1 ether to each project', async () => {

     /*
     A project creator cannot donate to their own project
     so we can change the donator account the be the second acccount.
     */
     donatorAccount = accounts[1];
     let contractInstance = await Projects.deployed();
     await contractInstance.donateToProject(0, {from: donatorAccount,
                                                value: 1});
     await contractInstance.donateToProject(1, {from: donatorAccount,
                                                value: 1});
     await contractInstance.donateToProject(2, {from: donatorAccount,
                                                value: 1});
     await contractInstance.donateToProject(3, {from: donatorAccount,
                                                value: 1});

     let projectsMap =  await contractInstance.returnProjects.call();
     // Each project should have raised 1 ether total.
     assert.equal(projectsMap[0].amountRaised,
                  1,
                  "Ether not donated successfully to 1st project");
     assert.equal(projectsMap[1].amountRaised,
                  1,
                  "Ether not donated successfully to 2nd project");
     assert.equal(projectsMap[2].amountRaised,
                  1,
                  "Ether not donated successfully to 3rd project");
     assert.equal(projectsMap[3].amountRaised,
                  1,
                  "Ether not donated successfully to 4th project");
   });

   it('Should check that the balance of the contract is 4 eth', async () => {
     let contractInstance = await Projects.deployed();
     let balance = await contractInstance.getContractBalance.call();
     assert.equal(balance.toString(), "4", "Contract Balance not correct")
   })

  it('should advance time', async () => {
    /*
    This function tests that the helper function which moves the block
    timestamp forward is working as expected.
    There are 86400 seconds in a day so this function should advance
    the clock 2 days.
    */
    const secondsToAdvance = (86400 * 2);
    const originalBlock = await web3.eth.getBlock('latest');
    const newBlock = await time.windClockForward(secondsToAdvance);
    const timeDifference = newBlock.timestamp - originalBlock.timestamp;

    /*
    Is the time difference between the new timestamp and the old timestamp
    greater than or equal to 2 days?
    The reason we add the greater than check is because checking exact
    timestamps on a blockchain is not recommended.
    Timestamps on the mining machine are what is checked and these can be off by
    15 seconds.
    For the purposes of this project and these tests this is ok as we just need
    to check that we have passed the timestamp which represents the start of
    a day.
    */
    assert.isTrue(timeDifference >= secondsToAdvance);
  })

  it('Should create a project that ends in two days', async () => {
    let contractInstance = await Projects.deployed();
    let secondsInADay = 86400;
    var testProjectInfoHash = "gfdgdfgdfgfdgdfgdfgfdg";
    var testFundingGoal = 10.000;
    var currentTime = await web3.eth.getBlock('latest')
    const testProjectEndDate = currentTime.timestamp + (86400 * 2);
    const result = await contractInstance.createProject(testProjectInfoHash,
                                                        testFundingGoal,
                                                        testProjectEndDate);

    // The projectHasEnded function returns a Bool.
    // This is the 5th Project we have created so the index is 4.
    const hasEnded = await contractInstance.projectHasEnded(4);
    assert.equal(hasEnded, false, "project has ended");
 })

 it('Should advance time by 2 days and the project should have ended', async () => {
   let contractInstance = await Projects.deployed();
   let secondsInADay = 86400;

   await time.windClockForward(secondsInADay * 2);
   const hasEnded = await contractInstance.projectHasEnded(4);
   assert.equal(hasEnded, true, "time advancement not working as intended");
 })

 it('Should test payOut function', async () => {

   // When a projects funding goal is reached the funds should be payed to the creator.
   let contractInstance = await Projects.deployed();
   const creatorAccount = accounts[4];
   const testProjectInfoHash = "fsgfdgdfgdfgdfgdfg";
   // Our sample project will have a funding goal of 10 ether
   const testFundingGoal = web3.utils.toWei('10.0');
   const currentTime = await web3.eth.getBlock('latest')
   const testProjectEndDate =  currentTime.timestamp + (86400 * 2);

   await contractInstance.createProject(testProjectInfoHash,
                                        testFundingGoal,
                                        testProjectEndDate,
                                        {from: creatorAccount});

   // Web 3 functions take ether and wei values as strings
   // We need to convert these back into ints if we want to compare their values
   const oldAccountBalance = parseInt(await web3.eth.getBalance(creatorAccount));
   const donationAmount = parseInt(web3.utils.toWei('10.0'));

   // This function donates 10 ether to the project with index 5
   await contractInstance.donateToProject(5, {value: donationAmount});

   const newAccountBalance = parseInt(await web3.eth.getBalance(creatorAccount));

   /*
   To check that our payout function has worked we check that the balance of the
   project creators account is greater than or equal to its old balance, (the
   balance before the donate function was called), plus the donation ammount.
   */
   assert.isTrue(newAccountBalance >= oldAccountBalance + donationAmount,
                 "Donation function not working as expected");
 })

 it('Should test payRefunds function', async () => {

   // When the end date of a project is reached, all donations should be refunded.
   let contractInstance = await Projects.deployed();
   const creatorAccount = accounts[4];
   const testProjectInfoHash = "gfdgfdgdfgdfgdfgdfg";
   const testFundingGoal = web3.utils.toWei('10.0');
   const currentTime = await web3.eth.getBlock('latest')
   // The end date for this project is 2 days from today.
   const testProjectEndDate =  currentTime.timestamp + (86400 * 2);

   await contractInstance.createProject(testProjectInfoHash,
                                        testFundingGoal,
                                        testProjectEndDate,
                                        {from: creatorAccount});


   // We doante 2 ether from 2 different accounts.
   const donationAmount = web3.utils.toWei('2.0');
   const donatorAccount1 = accounts[5];
   const donatorAccount2 = accounts[6];

   await contractInstance.donateToProject(6, {from: donatorAccount1,
                                              value: donationAmount});
   await contractInstance.donateToProject(6, {from: donatorAccount2,
                                              value: donationAmount});

   // Again we need to convert these to Ints so we can compare them later.
   const oldAccountBalance1 = parseInt(await web3.eth.getBalance(donatorAccount1));
   const oldAccountBalance2 = parseInt(await web3.eth.getBalance(donatorAccount2));

   // We advance the clock by 3 days. This project has now ended.
   await time.windClockForward(86400 * 3);
   await contractInstance.donateToProject(6, {value:donationAmount});

   // The doantors accounts should have been refunded so we recheck the balance.
   const newAccountBalance1 = parseInt(await web3.eth.getBalance(donatorAccount1));
   const newAccountBalance2 = parseInt(await web3.eth.getBalance(donatorAccount2));

   const donationAmountInt = parseInt(donationAmount)

   /*
   To check that our pay refund funcion has worked correctly we check that the
   new account balance for both donators is equal to their old balance, (after
   they donated but before the project ended), plus the donation amount.
   */
   assert.isTrue(newAccountBalance1 >= oldAccountBalance1 + donationAmountInt,
                 "Account 1 balance incorrect");
   assert.isTrue(newAccountBalance2 >= oldAccountBalance2 + donationAmountInt,
                 "Account 2 balance incorrect");
 })
 });
